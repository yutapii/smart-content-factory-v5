<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSSä¸€è¦§ - é…ä¿¡å…ƒç®¡ç† | SCF V5</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans JP', sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.8em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .back-btn {
            background: rgba(255,255,255,0.2);
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 8px;
            transition: background 0.3s;
        }

        .back-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
        }

        .stats-bar {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .control-row {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .add-form {
            display: flex;
            gap: 10px;
            flex: 1;
        }

        .add-form input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .add-form select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background: white;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .search-box {
            flex: 1;
            max-width: 300px;
        }

        .search-box input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .feed-list {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .feed-item {
            padding: 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s;
        }

        .feed-item:hover {
            background: #f8f9fa;
        }

        .feed-info {
            flex: 1;
        }

        .feed-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .feed-url {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
            word-break: break-all;
        }

        .feed-meta {
            display: flex;
            gap: 20px;
            font-size: 0.85em;
            color: #999;
        }

        .feed-category {
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 8px;
            border-radius: 3px;
        }

        .feed-error-badge {
            background: #ffebee;
            color: #c62828;
            padding: 2px 8px;
            border-radius: 3px;
            margin-left: 10px;
            cursor: help;
            animation: errorPulse 2s infinite;
        }

        @keyframes errorPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .feed-actions {
            display: flex;
            gap: 10px;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            margin-bottom: 20px;
        }

        .modal-header h2 {
            color: #333;
        }

        .close-modal {
            float: right;
            font-size: 28px;
            cursor: pointer;
            color: #999;
        }

        .close-modal:hover {
            color: #333;
        }

        .import-area {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            font-family: monospace;
            resize: vertical;
        }

        .file-input-container {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            text-align: center;
        }

        .file-input-label {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
        }

        .file-input {
            display: none;
        }

        .file-info {
            margin-top: 10px;
            color: #666;
            font-size: 0.9em;
        }

        .import-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .import-tab {
            padding: 10px 20px;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .import-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .import-panel {
            display: none;
        }

        .import-panel.active {
            display: block;
        }

        .import-preview {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .import-preview-item {
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.9em;
        }

        .import-preview-item:last-child {
            border-bottom: none;
        }

        .import-preview-item.error {
            background: #ffebee;
            color: #c62828;
        }

        .import-preview-item.duplicate {
            background: #fff3e0;
            color: #e65100;
        }

        .import-preview-item.success {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .category-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .category-tag {
            background: #f0f0f0;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .category-tag:hover {
            background: #e0e0e0;
        }

        .category-tag.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .empty-state-text {
            font-size: 1.2em;
        }

        @media (max-width: 768px) {
            .control-row {
                flex-direction: column;
            }
            
            .add-form {
                flex-direction: column;
            }
            
            .feed-item {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .feed-actions {
                margin-top: 10px;
                width: 100%;
                justify-content: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>ğŸ“° RSSä¸€è¦§ - é…ä¿¡å…ƒç®¡ç†</h1>
            <a href="../index.html" class="back-btn">â† ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã¸</a>
        </div>
    </div>

    <div class="container">
        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-value" id="totalFeeds">0</div>
                <div class="stat-label">ç™»éŒ²ãƒ•ã‚£ãƒ¼ãƒ‰æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="activeFeeds">0</div>
                <div class="stat-label">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="categoryCount">0</div>
                <div class="stat-label">ã‚«ãƒ†ã‚´ãƒªæ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="lastUpdate">--:--</div>
                <div class="stat-label">æœ€çµ‚æ›´æ–°</div>
            </div>
        </div>

        <div class="controls">
            <div class="control-row">
                <form class="add-form" id="addFeedForm">
                    <input type="text" id="feedName" placeholder="ãƒ•ã‚£ãƒ¼ãƒ‰åï¼ˆä¾‹ï¼šTechCrunchï¼‰" required>
                    <input type="url" id="feedUrl" placeholder="RSS URLï¼ˆhttps://...ï¼‰" required>
                    <select id="feedCategory">
                        <option value="">ã‚«ãƒ†ã‚´ãƒªé¸æŠ</option>
                        <option value="ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼">ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼</option>
                        <option value="ãƒ“ã‚¸ãƒã‚¹">ãƒ“ã‚¸ãƒã‚¹</option>
                        <option value="AIãƒ»æ©Ÿæ¢°å­¦ç¿’">AIãƒ»æ©Ÿæ¢°å­¦ç¿’</option>
                        <option value="ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—">ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—</option>
                        <option value="å®˜å…¬åº">å®˜å…¬åº</option>
                        <option value="ãã®ä»–">ãã®ä»–</option>
                    </select>
                    <button type="submit" class="btn btn-primary">è¿½åŠ </button>
                </form>
            </div>
            <div class="control-row">
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’æ¤œç´¢...">
                </div>
                <button class="btn btn-secondary" onclick="showImportModal()">ğŸ“¥ ä¸€æ‹¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
                <button class="btn btn-success" onclick="exportFeeds()">ğŸ“¤ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                <button class="btn btn-primary" onclick="updateAllFeeds()">ğŸ”„ å…¨ã¦æ›´æ–°</button>
            </div>
            <div class="category-tags" id="categoryFilter">
                <span class="category-tag active" data-category="all">ã™ã¹ã¦</span>
            </div>
        </div>

        <div class="feed-list" id="feedList">
            <div class="empty-state">
                <div class="empty-state-icon">ğŸ“¡</div>
                <div class="empty-state-text">ã¾ã ãƒ•ã‚£ãƒ¼ãƒ‰ãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“</div>
                <div class="empty-state-text">ä¸Šã®ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰è¿½åŠ ã—ã¦ãã ã•ã„</div>
            </div>
        </div>
    </div>

    <!-- ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div class="modal" id="importModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="close-modal" onclick="closeImportModal()">&times;</span>
                <h2>RSSãƒ•ã‚£ãƒ¼ãƒ‰ä¸€æ‹¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</h2>
            </div>
            
            <div class="import-tabs">
                <button class="import-tab active" onclick="switchImportTab('text')">ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›</button>
                <button class="import-tab" onclick="switchImportTab('file')">ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</button>
            </div>
            
            <!-- ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ãƒ‘ãƒãƒ« -->
            <div id="textImportPanel" class="import-panel active">
                <p>1è¡Œ1ãƒ•ã‚£ãƒ¼ãƒ‰ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆåå‰|URL|ã‚«ãƒ†ã‚´ãƒªï¼‰</p>
                <textarea class="import-area" id="importData" placeholder="TechCrunch|https://techcrunch.com/feed/|ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼
Bloomberg|https://www.bloomberg.com/feed/|ãƒ“ã‚¸ãƒã‚¹
MIT Tech Review|https://www.technologyreview.com/feed/|AIãƒ»æ©Ÿæ¢°å­¦ç¿’"></textarea>
            </div>
            
            <!-- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒ‘ãƒãƒ« -->
            <div id="fileImportPanel" class="import-panel">
                <div class="file-input-container">
                    <label for="fileInput" class="file-input-label">
                        ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
                    </label>
                    <input type="file" id="fileInput" class="file-input" accept=".txt,.csv,.tsv,.json" onchange="handleFileSelect(event)">
                    <div class="file-info" id="fileInfo">å¯¾å¿œå½¢å¼: .txt, .csv, .tsv, .json</div>
                </div>
                <div id="filePreview" style="display: none;">
                    <h4 style="margin-bottom: 10px;">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼:</h4>
                    <div class="import-preview" id="fileImportPreview"></div>
                </div>
            </div>
            
            <div style="margin-top: 20px; text-align: right;">
                <button type="button" class="btn btn-secondary" onclick="closeImportModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button type="button" class="btn btn-primary" id="importBtn" style="margin-left: 10px;">ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
            </div>
        </div>
    </div>

    <script>
        // IndexedDBè¨­å®š
        let db;
        const DB_NAME = 'SCFV5_RSS';
        const DB_VERSION = 2; // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’2ã«çµ±ä¸€

        // IndexedDBåˆæœŸåŒ–ï¼ˆæ”¹å–„ç‰ˆï¼‰
        async function initDB() {
            return new Promise((resolve, reject) => {
                // æ—¢å­˜ã®DBæ¥ç¶šã‚’é–‰ã˜ã‚‹
                if (db) {
                    try {
                        db.close();
                        db = null;
                    } catch (e) {
                        console.log('æ—¢å­˜DBæ¥ç¶šã®ã‚¯ãƒ­ãƒ¼ã‚ºä¸­ã®ã‚¨ãƒ©ãƒ¼ï¼ˆç„¡è¦–å¯ï¼‰:', e);
                    }
                }
                
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => {
                    console.error('IndexedDBæ¥ç¶šã‚¨ãƒ©ãƒ¼:', request.error);
                    // ã‚¨ãƒ©ãƒ¼ã§ã‚‚LocalStorageã§å‹•ä½œç¶™ç¶š
                    db = null;
                    resolve(null);
                };
                
                request.onsuccess = () => {
                    db = request.result;
                    console.log('IndexedDBæ¥ç¶šæˆåŠŸ: ãƒãƒ¼ã‚¸ãƒ§ãƒ³', db.version);
                    
                    // DBæ¥ç¶šãŒåˆ‡ã‚ŒãŸå ´åˆã®å‡¦ç†
                    db.onversionchange = () => {
                        db.close();
                        db = null;
                        console.log('DBãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒå¤‰æ›´ã•ã‚ŒãŸãŸã‚æ¥ç¶šã‚’é–‰ã˜ã¾ã—ãŸ');
                    };
                    
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    const oldVersion = event.oldVersion;
                    const newVersion = event.newVersion;
                    
                    console.log(`DBã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰: ${oldVersion} â†’ ${newVersion}`);
                    
                    // feeds storeï¼ˆRSSä¸€è¦§ç”¨ï¼‰
                    if (!db.objectStoreNames.contains('feeds')) {
                        const store = db.createObjectStore('feeds', { keyPath: 'id', autoIncrement: true });
                        store.createIndex('name', 'name', { unique: false });
                        store.createIndex('category', 'category', { unique: false });
                        store.createIndex('active', 'active', { unique: false });
                        console.log('feeds storeã‚’ä½œæˆã—ã¾ã—ãŸ');
                    }
                    
                    // articles storeï¼ˆé…ä¿¡RSSç”¨ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³2ã§è¿½åŠ ï¼‰
                    if (!db.objectStoreNames.contains('articles')) {
                        const articleStore = db.createObjectStore('articles', { keyPath: 'id', autoIncrement: true });
                        articleStore.createIndex('feedId', 'feedId', { unique: false });
                        articleStore.createIndex('pubDate', 'pubDate', { unique: false });
                        articleStore.createIndex('saved', 'saved', { unique: false });
                        console.log('articles storeã‚’ä½œæˆã—ã¾ã—ãŸ');
                    }
                };
                
                request.onblocked = () => {
                    console.warn('DBæ¥ç¶šãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ - ä»–ã®ã‚¿ãƒ–ã‚’é–‰ã˜ã¦ãã ã•ã„');
                    alert('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚\nä»–ã®ã‚¿ãƒ–ã‚’é–‰ã˜ã¦ã‹ã‚‰ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚');
                };
            });
        }

        // ãƒ•ã‚£ãƒ¼ãƒ‰è¿½åŠ 
        async function addFeed(feed) {
            // dbãŒæœªå®šç¾©ã®å ´åˆã¯åˆæœŸåŒ–
            if (!db) {
                await initDB();
                
                // ãã‚Œã§ã‚‚dbãŒnullã®å ´åˆã¯LocalStorageã‚’ä½¿ç”¨
                if (!db) {
                    console.log('LocalStorageã«ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’ä¿å­˜');
                    let feeds = [];
                    try {
                        const stored = localStorage.getItem('rss-feeds');
                        if (stored) {
                            feeds = JSON.parse(stored);
                        }
                    } catch (e) {
                        console.error('LocalStorageèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', e);
                        feeds = [];
                    }
                    
                    // æ–°ã—ã„ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’è¿½åŠ 
                    feed.id = Date.now() + Math.random();
                    feed.createdAt = new Date().toISOString();
                    feed.lastUpdate = new Date().toISOString();
                    feed.active = true;
                    feeds.push(feed);
                    
                    localStorage.setItem('rss-feeds', JSON.stringify(feeds));
                    return Promise.resolve(feed);
                }
            }
            
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['feeds'], 'readwrite');
                const store = transaction.objectStore('feeds');
                
                feed.active = true;
                feed.lastUpdate = new Date().toISOString();
                feed.createdAt = new Date().toISOString();
                
                const request = store.add(feed);
                
                request.onsuccess = () => {
                    console.log('ãƒ•ã‚£ãƒ¼ãƒ‰è¿½åŠ æˆåŠŸ:', feed.name);
                    resolve(request.result);
                };
                
                request.onerror = () => {
                    console.error('ãƒ•ã‚£ãƒ¼ãƒ‰è¿½åŠ ã‚¨ãƒ©ãƒ¼:', request.error);
                    reject(request.error);
                };
            });
        }

        // å…¨ãƒ•ã‚£ãƒ¼ãƒ‰å–å¾—
        async function getAllFeeds() {
            // dbãŒæœªå®šç¾©ã®å ´åˆã¯åˆæœŸåŒ–
            if (!db) {
                await initDB();
                
                // ãã‚Œã§ã‚‚dbãŒnullã®å ´åˆã¯LocalStorageã‹ã‚‰å–å¾—
                if (!db) {
                    console.log('LocalStorageã‹ã‚‰ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’å–å¾—');
                    try {
                        const stored = localStorage.getItem('rss-feeds');
                        if (stored) {
                            return JSON.parse(stored);
                        }
                    } catch (e) {
                        console.error('LocalStorageèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', e);
                    }
                    return [];
                }
            }
            
            const transaction = db.transaction(['feeds'], 'readonly');
            const store = transaction.objectStore('feeds');
            
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }

        // ãƒ•ã‚£ãƒ¼ãƒ‰å‰Šé™¤
        async function deleteFeed(id) {
            if (!db) {
                await initDB();
            }
            const transaction = db.transaction(['feeds'], 'readwrite');
            const store = transaction.objectStore('feeds');
            return store.delete(id);
        }

        // ãƒ•ã‚£ãƒ¼ãƒ‰æ›´æ–°
        async function updateFeed(feed) {
            if (!db) {
                await initDB();
            }
            const transaction = db.transaction(['feeds'], 'readwrite');
            const store = transaction.objectStore('feeds');
            feed.lastUpdate = new Date().toISOString();
            return store.put(feed);
        }

        // ãƒ•ã‚£ãƒ¼ãƒ‰è¡¨ç¤º
        async function displayFeeds(filter = '') {
            const feeds = await getAllFeeds();
            const feedList = document.getElementById('feedList');
            
            // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            let filteredFeeds = feeds;
            if (filter && filter !== 'all') {
                filteredFeeds = feeds.filter(f => f.category === filter);
            }
            
            // æ¤œç´¢ãƒ•ã‚£ãƒ«ã‚¿
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            if (searchTerm) {
                filteredFeeds = filteredFeeds.filter(f => 
                    f.name.toLowerCase().includes(searchTerm) ||
                    f.url.toLowerCase().includes(searchTerm) ||
                    (f.category && f.category.toLowerCase().includes(searchTerm))
                );
            }
            
            if (filteredFeeds.length === 0) {
                feedList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ğŸ“¡</div>
                        <div class="empty-state-text">ãƒ•ã‚£ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>
                    </div>
                `;
                return;
            }
            
            feedList.innerHTML = filteredFeeds.map(feed => `
                <div class="feed-item">
                    <div class="feed-info">
                        <div class="feed-name">${feed.name}</div>
                        <div class="feed-url">${feed.url}</div>
                        <div class="feed-meta">
                            ${feed.category ? `<span class="feed-category">${feed.category}</span>` : ''}
                            <span>æœ€çµ‚æ›´æ–°: ${new Date(feed.lastUpdate).toLocaleString('ja-JP')}</span>
                            <span>ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${feed.active ? 'âœ… ã‚¢ã‚¯ãƒ†ã‚£ãƒ–' : 'â¸ï¸ åœæ­¢ä¸­'}</span>
                            ${feed.fetchError ? `<span class="feed-error-badge" title="${feed.lastError || 'å–å¾—ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ'}">âš ï¸ å–å¾—ã‚¨ãƒ©ãƒ¼</span>` : ''}
                        </div>
                    </div>
                    <div class="feed-actions">
                        <button class="btn btn-small btn-primary" onclick="testFeed('${feed.url}', ${feed.id})">ãƒ†ã‚¹ãƒˆ</button>
                        <button class="btn btn-small btn-secondary" onclick="toggleFeed(${feed.id})">
                            ${feed.active ? 'åœæ­¢' : 'é–‹å§‹'}
                        </button>
                        <button class="btn btn-small btn-danger" onclick="removeFeed(${feed.id})">å‰Šé™¤</button>
                    </div>
                </div>
            `).join('');
            
            updateStats();
        }

        // çµ±è¨ˆæ›´æ–°
        async function updateStats() {
            const feeds = await getAllFeeds();
            document.getElementById('totalFeeds').textContent = feeds.length;
            document.getElementById('activeFeeds').textContent = feeds.filter(f => f.active).length;
            
            const categories = [...new Set(feeds.map(f => f.category).filter(c => c))];
            document.getElementById('categoryCount').textContent = categories.length;
            
            // ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ›´æ–°
            const categoryFilter = document.getElementById('categoryFilter');
            categoryFilter.innerHTML = `
                <span class="category-tag active" data-category="all" onclick="filterByCategory('all')">ã™ã¹ã¦</span>
                ${categories.map(cat => 
                    `<span class="category-tag" data-category="${cat}" onclick="filterByCategory('${cat}')">${cat}</span>`
                ).join('')}
            `;
            
            // æœ€çµ‚æ›´æ–°æ™‚åˆ»
            const now = new Date();
            document.getElementById('lastUpdate').textContent = 
                `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        }

        // ã‚«ãƒ†ã‚´ãƒªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
        function filterByCategory(category) {
            document.querySelectorAll('.category-tag').forEach(tag => {
                tag.classList.remove('active');
                if (tag.dataset.category === category) {
                    tag.classList.add('active');
                }
            });
            displayFeeds(category);
        }

        // ãƒ•ã‚£ãƒ¼ãƒ‰è¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ 
        document.getElementById('addFeedForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const feed = {
                name: document.getElementById('feedName').value,
                url: document.getElementById('feedUrl').value,
                category: document.getElementById('feedCategory').value
            };
            
            try {
                await addFeed(feed);
                e.target.reset();
                displayFeeds();
                alert('ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’è¿½åŠ ã—ã¾ã—ãŸ');
            } catch (error) {
                alert('ã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        });

        // æ¤œç´¢
        document.getElementById('searchInput').addEventListener('input', () => {
            displayFeeds(document.querySelector('.category-tag.active').dataset.category);
        });

        // ãƒ•ã‚£ãƒ¼ãƒ‰å‰Šé™¤
        async function removeFeed(id) {
            if (confirm('ã“ã®ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                await deleteFeed(id);
                displayFeeds();
            }
        }

        // ãƒ•ã‚£ãƒ¼ãƒ‰æœ‰åŠ¹/ç„¡åŠ¹åˆ‡ã‚Šæ›¿ãˆ
        async function toggleFeed(id) {
            const feeds = await getAllFeeds();
            const feed = feeds.find(f => f.id === id);
            if (feed) {
                feed.active = !feed.active;
                await updateFeed(feed);
                displayFeeds();
            }
        }

        // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆï¼ˆã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’DBã«ä¿å­˜ï¼‰
        async function testFeed(url, feedId = null) {
            // æ—¢çŸ¥ã®å•é¡ŒãŒã‚ã‚‹ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—
            const problematicDomains = [
                'bmbf.de', 'bsi.bund.de', 'economie.gouv.fr', 
                'ssi.gouv.fr', 'inria.fr', 'enisa.europa.eu',
                'digital.canada.ca', 'nrc.canada.ca'
            ];
            
            const urlDomain = new URL(url).hostname;
            if (problematicDomains.some(domain => urlDomain.includes(domain))) {
                // ãƒ­ã‚°ã‚’å‡ºã•ãšã«é™ã‹ã«å‡¦ç†
                const errorInfo = {
                    success: false,
                    message: 'âš ï¸ ã“ã®ã‚µã‚¤ãƒˆã¯ç¾åœ¨ã‚¢ã‚¯ã‚»ã‚¹åˆ¶é™ãŒã‚ã‚Šã¾ã™',
                    errorCode: 'RESTRICTED_SITE'
                };
                
                // DBæ›´æ–°
                if (feedId && db) {
                    try {
                        const transaction = db.transaction(['feeds'], 'readwrite');
                        const store = transaction.objectStore('feeds');
                        const feedRequest = store.get(feedId);
                        
                        feedRequest.onsuccess = () => {
                            const feed = feedRequest.result;
                            if (feed) {
                                feed.fetchError = true;
                                feed.lastError = errorInfo.message;
                                feed.lastErrorCode = errorInfo.errorCode;
                                feed.lastChecked = new Date().toISOString();
                                store.put(feed);
                            }
                        };
                    } catch (e) {
                        console.log('DBæ›´æ–°ã‚¹ã‚­ãƒƒãƒ—');
                    }
                }
                
                if (!feedId) alert(errorInfo.message);
                return errorInfo;
            }
            
            // è¨­å®šæ¸ˆã¿ã®Cloudflare Worker URLã‚’ä½¿ç”¨
            const workerUrl = 'https://polished-snow-477a.yutapii.workers.dev';
            let errorInfo = null;
            
            try {
                // console.logã‚’æ¡ä»¶ä»˜ãã«å¤‰æ›´ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ä»¥å¤–ã¯è¡¨ç¤ºã—ãªã„ï¼‰
                if (localStorage.getItem('debug-mode') === 'true') {
                    console.log('æ¥ç¶šãƒ†ã‚¹ãƒˆé–‹å§‹:', url);
                }
                const testUrl = `${workerUrl}?url=${encodeURIComponent(url)}`;
                // ã‚¨ãƒ©ãƒ¼ã‚’äº‹å‰ã«ã‚­ãƒ£ãƒƒãƒ
                let response;
                try {
                    response = await fetch(testUrl, {
                        mode: 'cors',
                        credentials: 'omit'
                    });
                } catch (fetchError) {
                    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã‚’é™ã‹ã«å‡¦ç†ï¼ˆãƒ­ã‚°ã‚’å‡ºã•ãªã„ï¼‰
                    return { 
                        success: false, 
                        message: `âŒ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼`,
                        errorCode: 'NETWORK_ERROR'
                    };
                }
                
                if (response.ok) {
                    const text = await response.text();
                    // HTMLãƒã‚§ãƒƒã‚¯
                    if (text.trim().startsWith('<!DOCTYPE') || text.trim().startsWith('<html')) {
                        errorInfo = {
                            success: false,
                            message: 'HTMLãƒšãƒ¼ã‚¸ãŒè¿”ã•ã‚Œã¾ã—ãŸï¼ˆRSSã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼‰',
                            errorCode: 'HTML_CONTENT'
                        };
                    } else if (text.includes('<rss') || text.includes('<feed') || text.includes('<item>') || text.includes('<entry>')) {
                        const parser = new DOMParser();
                        const xml = parser.parseFromString(text, 'text/xml');
                        const items = xml.querySelectorAll('item, entry');
                        errorInfo = {
                            success: true,
                            message: `âœ… ${items.length}ä»¶ã®è¨˜äº‹ã‚’å–å¾—`,
                            errorCode: null
                        };
                    } else {
                        errorInfo = {
                            success: false,
                            message: 'âš ï¸ æœ‰åŠ¹ãªRSSãƒ•ã‚£ãƒ¼ãƒ‰ã§ã¯ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
                            errorCode: 'INVALID_FEED'
                        };
                    }
                } else {
                    errorInfo = {
                        success: false,
                        message: `âŒ HTTP ${response.status}`,
                        errorCode: `HTTP_${response.status}`
                    };
                }
            } catch (firstError) {
                console.error('æ¥ç¶šãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', firstError);
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: RSS2JSON
                try {
                    const fallbackUrl = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(url)}`;
                    const response = await fetch(fallbackUrl, {
                        mode: 'cors',
                        credentials: 'omit'
                    }).catch(err => {
                        console.log('RSS2JSON error caught:', err.message);
                        return { ok: false, status: 0 };
                    });
                    
                    if (response.ok) {
                        try {
                            const responseData = await response.json();
                            if (responseData && responseData.status === 'ok') {
                                errorInfo = {
                                    success: true,
                                    message: `âœ… ${responseData.items ? responseData.items.length : 0}ä»¶ã®è¨˜äº‹ã‚’å–å¾—ï¼ˆRSS2JSONçµŒç”±ï¼‰`,
                                    errorCode: null
                                };
                            } else {
                                const errorMsg = responseData?.message || 'Unknown error';
                                errorInfo = {
                                    success: false,
                                    message: `âŒ ${errorMsg}`,
                                    errorCode: 'RSS2JSON_ERROR'
                                };
                            }
                        } catch (jsonError) {
                            console.error('JSON parse error:', jsonError);
                            errorInfo = {
                                success: false,
                                message: 'âŒ Invalid response format',
                                errorCode: 'JSON_PARSE_ERROR'
                            };
                        }
                    } else {
                        errorInfo = {
                            success: false,
                            message: `âŒ HTTP ${response.status}`,
                            errorCode: `HTTP_${response.status}`
                        };
                    }
                } catch (fallbackError) {
                    console.error('Fallback error:', fallbackError);
                    errorInfo = {
                        success: false,
                        message: 'âŒ Network error',
                        errorCode: 'NETWORK_ERROR'
                    };
                }
            }
            
            // ãƒ•ã‚£ãƒ¼ãƒ‰IDãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°DBæ›´æ–°
            if (feedId && db) {
                try {
                    const transaction = db.transaction(['feeds'], 'readwrite');
                    const store = transaction.objectStore('feeds');
                    const feedRequest = store.get(feedId);
                    
                    feedRequest.onsuccess = () => {
                        const feed = feedRequest.result;
                        if (feed) {
                            feed.fetchError = !errorInfo.success;
                            feed.lastError = errorInfo.success ? null : errorInfo.message;
                            feed.lastErrorCode = errorInfo.errorCode;
                            feed.lastChecked = new Date().toISOString();
                            store.put(feed);
                        }
                    };
                    
                    transaction.oncomplete = () => {
                        // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†å¾Œã«UIæ›´æ–°
                        displayFeeds();
                    };
                } catch (e) {
                    console.error('ãƒ•ã‚£ãƒ¼ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ã‚¨ãƒ©ãƒ¼:', e);
                }
            }
            
            // UIã¸ã®ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º
            alert(errorInfo.message);
            
            return errorInfo;
        }

        // å…¨ãƒ•ã‚£ãƒ¼ãƒ‰æ›´æ–°
        async function updateAllFeeds() {
            const feeds = await getAllFeeds();
            const activeFeeds = feeds.filter(f => f.active);
            
            if (activeFeeds.length === 0) {
                alert('ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ•ã‚£ãƒ¼ãƒ‰ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            alert(`${activeFeeds.length}å€‹ã®ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’æ›´æ–°ä¸­...`);
            
            let successCount = 0;
            let errorCount = 0;
            
            for (const feed of activeFeeds) {
                feed.lastUpdate = new Date().toISOString();
                
                // å„ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’ãƒ†ã‚¹ãƒˆã—ã¦ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’æ›´æ–°
                const result = await testFeed(feed.url, feed.id);
                if (result.success) {
                    successCount++;
                } else {
                    errorCount++;
                }
                
                await updateFeed(feed);
            }
            
            displayFeeds();
            
            let message = 'æ›´æ–°å®Œäº†ã—ã¾ã—ãŸ\n';
            message += `âœ… æˆåŠŸ: ${successCount}å€‹\n`;
            if (errorCount > 0) {
                message += `âŒ ã‚¨ãƒ©ãƒ¼: ${errorCount}å€‹`;
            }
            alert(message);
        }

        // ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ€ãƒ«
        function showImportModal() {
            document.getElementById('importModal').classList.add('active');
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã‹ã‚ŒãŸæ™‚ã«ã‚‚ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
            setTimeout(() => {
                const importBtn = document.getElementById('importBtn');
                if (importBtn) {
                    // æ—¢å­˜ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤
                    const newImportBtn = importBtn.cloneNode(true);
                    importBtn.parentNode.replaceChild(newImportBtn, importBtn);
                    
                    // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
                    newImportBtn.addEventListener('click', async function() {
                        console.log('ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«å†…ï¼‰');
                        await performImport();
                    });
                }
            }, 100);
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('active');
            document.getElementById('importData').value = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('fileInfo').textContent = 'å¯¾å¿œå½¢å¼: .txt, .csv, .tsv, .json';
            document.getElementById('filePreview').style.display = 'none';
            fileContent = '';
            currentImportTab = 'text';
            
            // ã‚¿ãƒ–ã‚’ãƒªã‚»ãƒƒãƒˆ
            document.querySelectorAll('.import-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector('.import-tab').classList.add('active');
            document.getElementById('textImportPanel').classList.add('active');
            document.getElementById('fileImportPanel').classList.remove('active');
        }

        // ãƒ•ã‚£ãƒ¼ãƒ‰ä¸€æ‹¬ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        let fileContent = '';
        let currentImportTab = 'text';
        
        async function performImport() {
            try {
                console.log('ã‚¤ãƒ³ãƒãƒ¼ãƒˆé–‹å§‹');
                console.log('currentImportTab:', currentImportTab);
                console.log('fileContent length:', fileContent.length);
                
                // DBã‚’å¼·åˆ¶çš„ã«åˆæœŸåŒ–ï¼ˆæ—¢å­˜ã®çŠ¶æ…‹ã«é–¢ã‚ã‚‰ãšï¼‰
                console.log('DBã‚’åˆæœŸåŒ–ä¸­...');
                try {
                    await initDB();
                    console.log('DBåˆæœŸåŒ–å®Œäº†, db=', db);
                } catch (dbError) {
                    console.error('DBåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', dbError);
                    alert('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚');
                    return;
                }
                
                let data;
                if (currentImportTab === 'text') {
                    data = document.getElementById('importData').value;
                } else {
                    data = fileContent;
                }
                
                if (!data || !data.trim()) {
                    alert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                await importFeeds(data);
                
            } catch (error) {
                console.error('performImport ã‚¨ãƒ©ãƒ¼:', error);
                alert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
            }
        }
        
        async function importFeeds(data) {
            console.log('importFeeds called with data length:', data.length);
            
            // DBã®ç¢ºèª
            if (!db) {
                console.log('importFeeds: DBãŒæœªåˆæœŸåŒ–ã®ãŸã‚å†åˆæœŸåŒ–');
                await initDB();
            }
            
            const lines = data.trim().split('\n');
            let imported = 0;
            let skipped = 0;
            let errors = [];
            
            // æ—¢å­˜ã®ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’å–å¾—ã—ã¦é‡è¤‡ãƒã‚§ãƒƒã‚¯ç”¨
            let existingFeeds = [];
            let existingUrls = [];
            
            try {
                existingFeeds = await getAllFeeds();
                existingUrls = existingFeeds.map(f => f.url.toLowerCase());
                console.log('æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ‰æ•°:', existingFeeds.length);
            } catch (e) {
                console.error('æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ‰å–å¾—ã‚¨ãƒ©ãƒ¼:', e);
                existingFeeds = [];
                existingUrls = [];
            }
            
            // JSONå½¢å¼ã®å ´åˆã®å‡¦ç†
            if (isJsonFormat(data)) {
                try {
                    const jsonData = JSON.parse(data);
                    const result = await importJsonFeeds(jsonData, existingUrls);
                    imported = result.imported;
                    skipped = result.skipped;
                    errors = result.errors;
                } catch (e) {
                    errors.push(`JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ${e.message}`);
                }
            } else {
                // ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã®å‡¦ç†
                for (const line of lines) {
                    if (!line.trim()) continue;
                    
                    let parts;
                    // CSVã¾ãŸã¯TSVã®å ´åˆ
                    if (line.includes('\t')) {
                        parts = line.split('\t');
                    } else if (line.includes(',') && !line.includes('|')) {
                        // CSVã®å ´åˆï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰
                        parts = parseCSVLine(line);
                    } else {
                        // ãƒ‘ã‚¤ãƒ—åŒºåˆ‡ã‚Šï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
                        parts = line.split('|');
                    }
                    
                    if (parts.length >= 2) {
                        const feedUrl = parts[1].trim();
                        
                        // URLæ¤œè¨¼
                        try {
                            new URL(feedUrl);
                        } catch (e) {
                            errors.push(`ç„¡åŠ¹ãªURL: ${feedUrl}`);
                            continue;
                        }
                        
                        // é‡è¤‡ãƒã‚§ãƒƒã‚¯
                        if (existingUrls.includes(feedUrl.toLowerCase())) {
                            skipped++;
                            continue;
                        }
                        
                        const feed = {
                            name: parts[0].trim(),
                            url: feedUrl,
                            category: parts[2] ? parts[2].trim() : 'ãã®ä»–'
                        };
                        
                        try {
                            await addFeed(feed);
                            imported++;
                            existingUrls.push(feedUrl.toLowerCase());
                        } catch (error) {
                            console.error('Import error:', error);
                            errors.push(`ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${feed.name}`);
                        }
                    }
                }
            }
            
            closeImportModal();
            
            // ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸå¾Œã«ãƒ•ã‚£ãƒ¼ãƒ‰ä¸€è¦§ã‚’æ›´æ–°
            await displayFeeds();
            
            let message = `âœ… ${imported}å€‹ã®ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`;
            if (skipped > 0) {
                message += `\nâš ï¸ ${skipped}å€‹ã¯æ—¢ã«ç™»éŒ²æ¸ˆã¿ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—`;
            }
            if (errors.length > 0) {
                message += `\nâŒ ã‚¨ãƒ©ãƒ¼: ${errors.length}å€‹\n${errors.slice(0, 5).join('\n')}`;
                if (errors.length > 5) {
                    message += `\n...ä»–${errors.length - 5}å€‹ã®ã‚¨ãƒ©ãƒ¼`;
                }
            }
            
            console.log('ã‚¤ãƒ³ãƒãƒ¼ãƒˆå®Œäº†:', message);
            alert(message);
            
            // ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦æœ€æ–°çŠ¶æ…‹ã‚’è¡¨ç¤º
            if (imported > 0) {
                setTimeout(() => {
                    location.reload();
                }, 1000);
            }
        }
        
        // JSONå½¢å¼ã‹ã©ã†ã‹ã‚’åˆ¤å®š
        function isJsonFormat(data) {
            const trimmed = data.trim();
            return (trimmed.startsWith('{') && trimmed.endsWith('}')) || 
                   (trimmed.startsWith('[') && trimmed.endsWith(']'));
        }
        
        // JSONãƒ•ã‚£ãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†
        async function importJsonFeeds(jsonData, existingUrlsArray) {
            let imported = 0;
            let skipped = 0;
            let errors = [];
            
            // existingUrlsã‚’é…åˆ—ã®ã‚³ãƒ”ãƒ¼ã¨ã—ã¦ä½œæˆï¼ˆå…ƒã®é…åˆ—ã‚’å¤‰æ›´ã—ãªã„ãŸã‚ï¼‰
            const existingUrls = [...existingUrlsArray];
            
            // ãƒ•ãƒ©ãƒƒãƒˆãªãƒ•ã‚£ãƒ¼ãƒ‰é…åˆ—ã‚’ä½œæˆ
            let feedsToImport = [];
            
            console.log('JSONãƒ‡ãƒ¼ã‚¿æ§‹é€ :', jsonData); // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
            
            // v4å½¢å¼ã®JSONæ§‹é€ ã«å¯¾å¿œï¼ˆãƒã‚¹ãƒˆã•ã‚ŒãŸã‚«ãƒ†ã‚´ãƒªæ§‹é€ ï¼‰
            if (jsonData.feeds && Array.isArray(jsonData.feeds)) {
                console.log('v4å½¢å¼ã‚’æ¤œå‡º');
                for (const categoryGroup of jsonData.feeds) {
                    const category = categoryGroup.category || 'ãã®ä»–';
                    if (categoryGroup.feeds && Array.isArray(categoryGroup.feeds)) {
                        for (const feed of categoryGroup.feeds) {
                            feedsToImport.push({
                                name: feed.name || feed.title || 'ç„¡é¡Œ',
                                url: feed.url || feed.link || '',
                                category: category,
                                description: feed.description || '',
                                tags: feed.tags || [],
                                priority: feed.priority || 'normal',
                                language: feed.language || 'ja'
                            });
                        }
                    }
                }
            }
            // ãƒ•ãƒ©ãƒƒãƒˆé…åˆ—å½¢å¼ã®JSON
            else if (Array.isArray(jsonData)) {
                console.log('é…åˆ—å½¢å¼ã‚’æ¤œå‡º');
                feedsToImport = jsonData.map(feed => ({
                    name: feed.name || feed.title || 'ç„¡é¡Œ',
                    url: feed.url || feed.link || '',
                    category: feed.category || 'ãã®ä»–',
                    description: feed.description || ''
                }));
            }
            // å˜ä¸€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼
            else if (jsonData.name && jsonData.url) {
                console.log('å˜ä¸€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼ã‚’æ¤œå‡º');
                feedsToImport = [{
                    name: jsonData.name,
                    url: jsonData.url,
                    category: jsonData.category || 'ãã®ä»–'
                }];
            }
            
            console.log(`ã‚¤ãƒ³ãƒãƒ¼ãƒˆå¯¾è±¡: ${feedsToImport.length}ä»¶`);
            
            // å„ãƒ•ã‚£ãƒ¼ãƒ‰ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
            for (const feedData of feedsToImport) {
                if (!feedData.url) {
                    errors.push(`URLãŒç©º: ${feedData.name}`);
                    continue;
                }
                
                // URLæ¤œè¨¼
                try {
                    new URL(feedData.url);
                } catch (e) {
                    errors.push(`ç„¡åŠ¹ãªURL: ${feedData.url}`);
                    continue;
                }
                
                // é‡è¤‡ãƒã‚§ãƒƒã‚¯
                if (existingUrls.includes(feedData.url.toLowerCase())) {
                    skipped++;
                    console.log(`é‡è¤‡ã‚¹ã‚­ãƒƒãƒ—: ${feedData.name}`);
                    continue;
                }
                
                const feed = {
                    name: feedData.name,
                    url: feedData.url,
                    category: feedData.category
                };
                
                // è¿½åŠ ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°ä¿å­˜
                if (feedData.description) feed.description = feedData.description;
                if (feedData.tags) feed.tags = feedData.tags;
                if (feedData.priority) feed.priority = feedData.priority;
                if (feedData.language) feed.language = feedData.language;
                
                try {
                    await addFeed(feed);
                    imported++;
                    existingUrls.push(feedData.url.toLowerCase());
                    console.log(`ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ: ${feedData.name}`);
                } catch (error) {
                    console.error('Import error for', feedData.name, ':', error);
                    // ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’è¨˜éŒ²
                    const errorMsg = error?.message || error?.toString() || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼';
                    errors.push(`${feedData.name}: ${errorMsg}`);
                }
            }
            
            console.log(`çµæœ: æˆåŠŸ=${imported}, ã‚¹ã‚­ãƒƒãƒ—=${skipped}, ã‚¨ãƒ©ãƒ¼=${errors.length}`);
            return { imported, skipped, errors };
        }
        
        // CSVè¡Œã®ãƒ‘ãƒ¼ã‚¹ï¼ˆã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã€å¼•ç”¨ç¬¦å¯¾å¿œï¼‰
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            
            return result.map(s => s.replace(/^"|"$/g, ''));
        }
        
        // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
        function switchImportTab(tab) {
            currentImportTab = tab;
            
            // ã‚¿ãƒ–ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.import-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // ãƒ‘ãƒãƒ«ã®è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
            document.getElementById('textImportPanel').classList.toggle('active', tab === 'text');
            document.getElementById('fileImportPanel').classList.toggle('active', tab === 'file');
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠãƒãƒ³ãƒ‰ãƒ©
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                fileContent = '';
                return;
            }
            
            const fileInfo = document.getElementById('fileInfo');
            fileInfo.textContent = `é¸æŠ: ${file.name} (${(file.size / 1024).toFixed(2)} KB)`;
            
            console.log('ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ:', file.name, file.type, file.size);
            
            try {
                fileContent = await readFile(file);
                console.log('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æˆåŠŸ, ã‚µã‚¤ã‚º:', fileContent.length);
                showFilePreview(fileContent);
            } catch (error) {
                console.error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
                alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                fileContent = '';
            }
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼'));
                reader.readAsText(file, 'UTF-8');
            });
        }
        
        // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
        async function showFilePreview(content) {
            const previewContainer = document.getElementById('filePreview');
            const preview = document.getElementById('fileImportPreview');
            
            if (!content.trim()) {
                previewContainer.style.display = 'none';
                return;
            }
            
            const lines = content.trim().split('\n').slice(0, 10); // æœ€åˆã®10è¡Œã‚’è¡¨ç¤º
            const existingFeeds = await getAllFeeds();
            const existingUrls = existingFeeds.map(f => f.url.toLowerCase());
            
            let previewHtml = '';
            let validCount = 0;
            let duplicateCount = 0;
            let errorCount = 0;
            
            // JSONå½¢å¼ã®å ´åˆã®å‡¦ç†
            if (isJsonFormat(content)) {
                try {
                    const jsonData = JSON.parse(content);
                    
                    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ã®ãƒ•ã‚£ãƒ¼ãƒ‰é…åˆ—ã‚’ä½œæˆï¼ˆå®Ÿéš›ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆã¯ã—ãªã„ï¼‰
                    const feedsToShow = [];
                    let allFeeds = [];
                    
                    // v4å½¢å¼ã®JSONæ§‹é€ ã‚’è§£æ
                    if (jsonData.feeds && Array.isArray(jsonData.feeds)) {
                        for (const categoryGroup of jsonData.feeds) {
                            const category = categoryGroup.category || 'ãã®ä»–';
                            if (categoryGroup.feeds && Array.isArray(categoryGroup.feeds)) {
                                for (const feed of categoryGroup.feeds) {
                                    allFeeds.push({
                                        name: feed.name || feed.title || 'ç„¡é¡Œ',
                                        url: feed.url || feed.link || '',
                                        category: category
                                    });
                                }
                            }
                        }
                    }
                    // ãƒ•ãƒ©ãƒƒãƒˆé…åˆ—å½¢å¼
                    else if (Array.isArray(jsonData)) {
                        allFeeds = jsonData.map(feed => ({
                            name: feed.name || feed.title || 'ç„¡é¡Œ',
                            url: feed.url || feed.link || '',
                            category: feed.category || 'ãã®ä»–'
                        }));
                    }
                    // å˜ä¸€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼
                    else if (jsonData.name && jsonData.url) {
                        allFeeds = [{
                            name: jsonData.name,
                            url: jsonData.url,
                            category: jsonData.category || 'ãã®ä»–'
                        }];
                    }
                    
                    // çµ±è¨ˆæƒ…å ±ã‚’è¨ˆç®—
                    for (const feed of allFeeds) {
                        if (!feed.url) {
                            errorCount++;
                            continue;
                        }
                        
                        try {
                            new URL(feed.url);
                            if (existingUrls.includes(feed.url.toLowerCase())) {
                                duplicateCount++;
                            } else {
                                validCount++;
                            }
                        } catch (e) {
                            errorCount++;
                        }
                    }
                    
                    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºï¼ˆæœ€åˆã®10ä»¶ï¼‰
                    for (const feed of allFeeds.slice(0, 10)) {
                        const url = feed.url;
                        let className = 'success';
                        let status = 'âœ… æ–°è¦';
                        
                        if (!url) {
                            className = 'error';
                            status = 'âŒ URLãªã—';
                        } else {
                            try {
                                new URL(url);
                                if (existingUrls.includes(url.toLowerCase())) {
                                    className = 'duplicate';
                                    status = 'âš ï¸ é‡è¤‡';
                                }
                            } catch (e) {
                                className = 'error';
                                status = 'âŒ ç„¡åŠ¹';
                            }
                        }
                        
                        previewHtml += `
                            <div class="import-preview-item ${className}">
                                ${status} | ${feed.name} | ${feed.category}
                            </div>
                        `;
                    }
                    
                    if (allFeeds.length > 10) {
                        previewHtml += `<div style="text-align: center; color: #666; margin-top: 10px;">... ä»– ${allFeeds.length - 10} ä»¶ã®ãƒ•ã‚£ãƒ¼ãƒ‰</div>`;
                    }
                    
                } catch (e) {
                    previewHtml += `
                        <div class="import-preview-item error">
                            âŒ JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ${e.message}
                        </div>
                    `;
                    errorCount++;
                }
            } else {
                // ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã®å‡¦ç†
                for (const line of lines) {
                    if (!line.trim()) continue;
                    
                    let parts;
                    if (line.includes('\t')) {
                        parts = line.split('\t');
                    } else if (line.includes(',') && !line.includes('|')) {
                        parts = parseCSVLine(line);
                    } else {
                        parts = line.split('|');
                    }
                    
                    if (parts.length >= 2) {
                    const url = parts[1].trim();
                    let className = 'success';
                    let status = 'âœ… æ–°è¦';
                    
                    try {
                        new URL(url);
                        if (existingUrls.includes(url.toLowerCase())) {
                            className = 'duplicate';
                            status = 'âš ï¸ é‡è¤‡';
                            duplicateCount++;
                        } else {
                            validCount++;
                        }
                    } catch (e) {
                        className = 'error';
                        status = 'âŒ ç„¡åŠ¹';
                        errorCount++;
                    }
                    
                    previewHtml += `
                        <div class="import-preview-item ${className}">
                            ${status} | ${parts[0].trim()} | ${url}
                        </div>
                    `;
                    } else {
                        previewHtml += `
                            <div class="import-preview-item error">
                                âŒ ç„¡åŠ¹ãªå½¢å¼: ${line.substring(0, 50)}...
                            </div>
                        `;
                        errorCount++;
                    }
                }
            }
            
            const totalLines = content.trim().split('\n').length;
            if (totalLines > 10) {
                previewHtml += `<div style="text-align: center; color: #666; margin-top: 10px;">... ä»– ${totalLines - 10} è¡Œ</div>`;
            }
            
            previewHtml = `
                <div style="margin-bottom: 10px; font-weight: bold;">
                    âœ… æ–°è¦: ${validCount} | âš ï¸ é‡è¤‡: ${duplicateCount} | âŒ ã‚¨ãƒ©ãƒ¼: ${errorCount}
                </div>
                ${previewHtml}
            `;
            
            preview.innerHTML = previewHtml;
            previewContainer.style.display = 'block';
        }

        // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        async function exportFeeds() {
            const feeds = await getAllFeeds();
            const exportData = feeds.map(f => `${f.name}|${f.url}|${f.category || ''}`).join('\n');
            
            const blob = new Blob([exportData], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `rss-feeds-${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOMContentLoaded: åˆæœŸåŒ–é–‹å§‹');
            
            try {
                await initDB();
                console.log('åˆæœŸDBåˆæœŸåŒ–å®Œäº†');
            } catch (e) {
                console.error('åˆæœŸDBåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', e);
            }
            
            await displayFeeds();
            
            // ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆåˆå›ã®ã¿ï¼‰
            const feeds = await getAllFeeds();
            if (feeds.length === 0) {
                const samples = [
                    { name: 'TechCrunch Japan', url: 'https://jp.techcrunch.com/feed/', category: 'ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼' },
                    { name: 'GIGAZINE', url: 'https://gigazine.net/news/rss_2.0/', category: 'ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼' },
                    { name: 'ITmedia AI+', url: 'https://rss.itmedia.co.jp/rss/2.0/aiplus.xml', category: 'AIãƒ»æ©Ÿæ¢°å­¦ç¿’' }
                ];
                
                for (const sample of samples) {
                    await addFeed(sample);
                }
                displayFeeds();
            }
            
            // ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ã«ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
            const importBtn = document.getElementById('importBtn');
            if (importBtn) {
                importBtn.addEventListener('click', async function() {
                    console.log('ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ãŒã‚¯ãƒªãƒƒã‚¯ã•ã‚Œã¾ã—ãŸ');
                    await performImport();
                });
            } else {
                console.error('ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
        });
    </script>
</body>
</html>